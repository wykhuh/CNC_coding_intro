
# ========================================================
# ========================================================

use `class()` to get the type.  

```{r}
class(inat_raw$quality_grade)
```

:::::::::::::::::::::::::::::::::::::::::: callout

**`tidyverse` vs. base R**


The phrase **base R** is used to refer to approaches that utilize functions contained in R's default packages. We have already used some base R functions, such as  `head()` and we will be using more scattered throughout this lesson.  


We choose to teach the `tidyverse` set of packages because they share a similar syntax and philosophy, making them consistent and producing highly readable code. The two `tidyverse` packages we will use are `readr` `ggplot2` for graphing, and `dplyr` for data manipulation.

::::::::::::::::::::::::::::::::::::::::::

Use View() to open a dataframe in a new window
 
```{r}
View(inat)
```



To select all columns except specific columns, put a `-` in front of the column you want to exclude:

```{r}
select(inat, -id, -user_id, -taxon_id)
```

:::::::::::::::::::::::::::::::::::::::::: callout

Between `select()` and `filter()`, it can be hard to remember which operates on columns and which operates on rows. `sele`**`c`**`t()` has a **c** for **c**olumns and `filte`**`r`**`()` has an **r** for **r**ows.

::::::::::::::::::::::::::::::::::::::::::


Since our new column gets moved all the way to the end, it doesn't end up printing out. We can use the `relocate()` function to put it after our `observed_on` column:

```{r}
inat %>% 
  mutate(year = year(observed_on)) %>%
  relocate(year, .after = observed_on)
```

:::::::::::::::::::::::::::::::::::::::::::: instructor
It's worth showing the learners that you can run a **pipeline** without highlighting the whole thing. If your cursor is on any line of a pipeline, running that line will run the whole thing.

You can also show that by highlighting a section of a pipeline, you can run only the first X steps of it.
::::::::::::::::::::::::::::::::::::::::::::



If we want to store this final product as an object, we use an assignment arrow at the start:

```{r}
my_observations_2_species <- inat %>% 
  select(user_login, observed_on, common_name) %>% 
  filter(user_login == 'natureinla' & common_name %in% c('Red-eared Slider', 'Monarch'))

```

A good approach is to build a pipeline step by step prior to assignment. You add functions to the pipeline as you go, with the results printing in the console for you to view. Once you're satisfied with your final result, go back and add the assignment arrow statement at the start. This approach is very interactive, allowing you to see the results of each step as you build the pipeline, and produces nicely readable code.




## The split-apply-combine approach

Many data analysis tasks can be achieved using the split-apply-combine approach: you split the data into groups, apply some analysis to each group, and combine the results in some way. `dplyr` has a few convenient functions to enable this approach, the main two being `group_by()` and `summarize()`.

`group_by()` takes a data.frame and the name of one or more columns with categorical values that define the groups. `summarize()` then collapses each group into a one-row summary of the group, giving you back a data.frame with one row per group. The syntax for `summarize()` is similar to `mutate()`, where you define new columns based on values of other columns. The function `n()` will count the number of rows in each group.  Let's try counting of all our observations by quality grade.

```{r}
inat %>% 
  group_by(quality_grade)  %>%
  summarize(count = n())
```


You will often want to create groups based on multiple columns. For example, we might be interested in the count of every quality grade  + coordinates obscured combination. All we have to do is add another column to our `group_by()` call.

```{r}
inat %>% 
  group_by(quality_grade, coordinates_obscured)  %>%
  summarize(count = n())
```

 
 It's often useful to take a look at the results in some order, like the lowestcount to highest. We can use the `arrange()` function for that:

```{r}
inat %>% 
  group_by(quality_grade, coordinates_obscured)  %>%
  summarize(count = n()) %>% 
  arrange(count)
```

If we want to reverse the order, we can wrap the column name in `desc()`:

```{r}
inat %>% 
  group_by(quality_grade, coordinates_obscured)  %>%
  summarize(count = n()) %>% 
  arrange(desc(count))
```

You may have seen several messages saying `summarise() has grouped output by 'quality_grade'. You can override using the .groups argument.` These are warning you that your resulting data.frame has retained some group structure, which means any subsequent operations on that data.frame will happen at the group level. If you look at the resulting data.frame printed out in your console, you will see these lines:

```
# A tibble: 6 × 3
# Groups:   quality_grade [3]
```

They tell us we have a data.frame with 6 rows, 3 columns, and a group variable `quality_grade`, for which there are 3 groups. 


Groups are often maintained throughout a pipeline, and if you assign the resulting data.frame to a new object, it will also have those groups. This can lead to confusing results if you forget about the grouping and want to carry out operations on the whole data.frame, not by group. Therefore, it is a good habit to remove the groups at the end of a pipeline containing `group_by()`:

```{r}
inat %>% 
  group_by(quality_grade, coordinates_obscured)  %>%
  summarize(count = n()) %>% 
  arrange(desc(count)) %>% 
  ungroup()
```

Now our data.frame just says `# A tibble: 6 × 3` at the top, with no groups.

While it is common that you will want to get the one-row-per-group summary that `summarise()` provides, there are times where you want to calculate a per-group value but keep all the rows in your data.frame. For example, we might want to know the count for each quality_grade + coordinates_obscured combination. For this, we can use `group_by()` and `mutate()` together:

```{r}
inat %>% 
  group_by(quality_grade, coordinates_obscured)  %>%
  mutate(count = n()) 
 
```
 

Since we get all our columns back, the new columns are at the very end and don't print out in the console. Let's use `select()` to just look at the columns of interest.  

```{r}
inat %>% 
  group_by(quality_grade, coordinates_obscured)  %>%
  mutate(count = n())  %>% 
  select(user_login, time_observed_at, common_name, quality_grade, coordinates_obscured, count)
```

What happens with the `group_by()` + `mutate()` combination is similar to using `summarize()`: for each group, the count is calculated. However, instead of reporting only one row per group, the count for each group is added to each row in that group. For each row in a group, you will see the same value in `count`.

::::::::::::::::::::::::::::::::::::: challenge 

## Challenge 4: Making a time series

1. Use the split-apply-combine approach to make a `data.frame` that counts the  number of iconic taxon name  observed each year. 

:::::::::::::::::::::::: solution 

```{r}

 inat %>% 
  mutate(year = year(observed_on))  %>%
  group_by(year, iconic_taxon_name) %>% 
  summarize(n = n())

```
```{r}

# shorter approach using count()
inat_iconic_taxon_counts <- inat %>% 
  mutate(year = year(observed_on))  %>%
  count(year, iconic_taxon_name) 

inat_iconic_taxon_counts
```


::::::::::::::::::::::::

2. Now use the data.frame you just made to plot the  number of  observations per year grouped by iconic taxon name. It's up to you what `geom` to use, but a `line` plot might be a good choice. 
:::::::::::::::::::::::: solution 

```{r}
inat_iconic_taxon_counts %>% 
  ggplot(aes(x = year, y = n, color = iconic_taxon_name)) +
  geom_line()
```

::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::


::::::::::::::::::::::::::::::::::::: keypoints 

- use `filter()` to subset rows and `select()` to subset columns
- build up pipelines one step at a time before assigning the result
- it is often best to keep components of dates separate until needed, then use `mutate()` to make a date column
- `group_by()` can be used with `summarize()` to collapse rows or `mutate()` to keep the same number of rows

::::::::::::::::::::::::::::::::::::::::::::::::

 
  We can view the first few rows with the `head()` function, and the last few rows with the `tail()` function:


```{r}
head(inat)
```

```{r}
tail(inat)
```

## %in%

Another useful operator is `%in%`, which asks if the value on the lefthand side is found anywhere in the vector on the righthand side. 

For example, to get rows with where `common_name` is "Western Fence Lizard" or "Western Honey Bee", we could run:


```{r}
inat %>% 
  filter(common_name %in% c("Western Fence Lizard", "Western Honey Bee")) %>% 
  select(user_login, observed_on, common_name) 


```

## Exercise 1

1. Create a data.frame with all of your observations. 

- Use `select()` and `filter`  
- The data.frame should have `user_login`, `observed_on`, and `common-name`. 

:::::::::::::::::::::::: solution

```{r}
inat %>% 
  filter(user_login == 'natureinla') %>% 
  select(user_login, observed_on, common_name) 
  
```

::::::::::::::::::::::::



```{r}
inat %>% 
  select(user_login, observed_on, common_name) %>% 
    filter( common_name == 'Western Fence Lizard' 
         & quality_grade == 'research') 
```



You will often want to create groups based on multiple columns. For example, we might be interested in the count of every common_name  + year combination. 


```{r}
inat %>% 
  mutate(year = year(observed_on)) %>%
  count(year, common_name, name='obs_count') 
```


We can use `gtsave` from `gt` to save dataframes as images, pdf, Word docuement.

`.html`, `.htm` (HTML file)
`.png` (PNG file)
`.pdf` (PDF file)
`.tex`, `.rnw` (LaTeX file)
`.rtf` (RTF file)
`.docx` (Word file)

```{r}
path = here("data", "cleaned", "top_ten_species1.png")

top_obs %>% 
  gt() %>% 
  tab_header(title="City Nature Challenge - Los Angeles 2012-2023",
    subtitle = "Top ten observed species") %>%
    gtsave(path, expand = 10)
```

```{r}
set_flextable_defaults(
  font.size = 10 ,
  padding = 6,
  theme_fun = theme_vanilla,
  background.color = "#FFFFFF"
)

ft <- flextable(top_obs)

path = here("data", "cleaned", "top_ten_species2.png")
save_as_image(ft, path = path)

```
