# 

https://r.geocompx.org/adv-map

```{r}
library(sf)
library(terra)
library(dplyr)
library(spData)
library(spDataLarge)

library(tmap)    # for static and interactive maps
library(leaflet) # for interactive maps
library(ggplot2) # tidyverse data visualization package
```

install.packages("tmap", repos = c("https://r-tmap.r-universe.dev",
                                   "https://cloud.r-project.org"))
                                   
install.packages("spDataLarge", repos = "https://geocompr.r-universe.dev")

```{r}
nz_elev = rast(system.file("raster/nz_elev.tif", package = "spDataLarge"))

```

### 2.2.3 Basic map making

Basic maps are created in sf with plot(). By default this creates a multi-panel plot, one sub-plot for each variable of the object, as illustrated in the left-hand panel in Figure 2.4. A legend or ‘key’ with a continuous color is produced if the object to be plotted has a single variable (see the right-hand panel). Colors can also be set with col =, although this will not create a continuous palette or a legend.

spData - world
sf - plot
```{r}

plot(world[3:6])
```

```{r}
plot(world["pop"])
```

overlaying circles, whose diameters (set with cex =) represent country populations, on a map of the world.

```{r}
plot(world["continent"], reset = FALSE)
cex = sqrt(world$pop) / 10000
world_cents = st_centroid(world, of_largest = TRUE)
plot(st_geometry(world_cents), add = TRUE, cex = cex)
```

sf’s plot method also has arguments specific to geographic data. expandBB, for example, can be used to plot an sf object in context: it takes a numeric vector of length four that expands the bounding box of the plot relative to zero in the following order: bottom, left, top, right. This is used to plot India in the context of its giant Asian neighbors, with an emphasis on China to the east

```{r}
india = world[world$name_long == "India", ]
plot(st_geometry(india), expandBB = c(0, 0.2, 0.1, 1), col = "gray", lwd = 3)
# plot(st_geometry(world_asia), add = TRUE)
```

## 9.2 Static maps

tmap is a powerful and flexible map-making package with sensible defaults. It has a concise syntax that allows for the creation of attractive maps with minimal code which will be familiar to ggplot2 users. It also has the unique capability to generate static and interactive maps using the same code via tmap_mode(). Finally, it accepts a wider range of spatial classes (including sf and terra objects) than alternatives such as ggplot2.

### 9.2.1 tmap basics

Like ggplot2, tmap is based on the idea of a ‘grammar of graphics’ (Wilkinson and Wills 2005). This involves a separation between the input data and the aesthetics (how data are visualized): each input dataset can be ‘mapped’ in a range of different ways including location on the map (defined by data’s geometry), color, and other visual variables. The basic building block is tm_shape() (which defines input data: an vector or raster object), followed by one or more layer elements such as tm_fill() and tm_dots(). 

```{r}
# Add fill layer to nz shape
tm_shape(nz) +
  tm_fill() 

```

```{r}
# Add border layer to nz shape
tm_shape(nz) +
  tm_borders() 

```


```{r}
# Add fill and border layers to nz shape
tm_shape(nz) +
  tm_fill() +
  tm_borders() 
```

The object passed to tm_shape() in this case is nz, an sf object representing the regions of New Zealand. Layers are added to represent nz visually, with tm_fill() and tm_borders() creating shaded areas (left panel) and border outlines (middle panel) in Figure 9.1, respectively.

tm_fill(): shaded areas for (mutli)polygons
tm_borders(): border outlines for (mutli)polygons
tm_polygons(): both, shaded areas and border outlines for (mutli)polygons
tm_lines(): lines for (mutli)linestrings
tm_symbols(): symbols for (mutli)points, (mutli)linestrings, and (mutli)polygons
tm_raster(): colored cells of raster data (there is also tm_rgb() for rasters with three layers)
tm_text(): text information for (mutli)points, (mutli)linestrings, and (mutli)polygons

### 9.2.2 Map objects

```{r}
tm_shape(nz) + tm_polygons()
```

 saving the last plot

```{r}
map_nz = tm_shape(nz) + tm_polygons()
class(map_nz)
```

Building on the previously created map_nz object, creates a new map object map_nz1 that contains another shape (nz_elev) representing average elevation across New Zealand

```{r}
map_nz1 = map_nz +
  tm_shape(nz_elev) + tm_raster(col_alpha = 0.7)

map_nz1
```
```{r}
tm_shape(nz_elev) + tm_raster(col_alpha = 0.7)
```
creates nz_water, representing New Zealand’s territorial waters, and adds the resulting lines to an existing map object.

```{r}
nz_water = st_union(nz) |>
  st_buffer(22200) |> 
  st_cast(to = "LINESTRING")

map_nz2 = map_nz1 +
  tm_shape(nz_water) + tm_lines()

map_nz2
```

```{r}
map_nz3 = map_nz2 +
  tm_shape(nz_height) + tm_symbols()

map_nz3
```

### 9.2.3 Visual variables

fill: fill color of a polygon
col: color of a polygon border, line, point, or raster
lwd: line width
lty: line type
size: size of a symbol
shape: shape of a symbol

```{r}
ma1 = tm_shape(nz) + tm_polygons(fill = "red")
ma2 = tm_shape(nz) + tm_polygons(fill = "red", fill_alpha = 0.3)
ma3 = tm_shape(nz) + tm_polygons(col = "blue")
ma4 = tm_shape(nz) + tm_polygons(lwd = 3)
ma5 = tm_shape(nz) + tm_polygons(lty = 2)
ma6 = tm_shape(nz) + tm_polygons(fill = "red", fill_alpha = 0.3,
                                 col = "blue", lwd = 3, lty = 2)
tmap_arrange(ma1, ma2, ma3, ma4, ma5, ma6)
```

## 9.4 Interactive maps
 
```{r}
# tmap_mode('plot')
 tmap_mode('view')

```
 
```{r}
world_coffee = left_join(world, coffee_data, by = "name_long")
facets = c("coffee_production_2016", "coffee_production_2017")
tm_shape(world_coffee) + tm_polygons(facets) + 
  tm_facets_wrap(nrow = 1, sync = TRUE)
```
 
 If you are not proficient with tmap, the quickest way to create interactive maps in R may be with mapview
 
```{r}
mapview::mapview(nz)

```
 
 In essence, it can be considered a data-driven leaflet API (see below for more information about leaflet). Given that mapview always expects a spatial object (including sf and SpatRaster) as its first argument, it works well at the end of piped expressions.
 
  By default, mapview uses the leaflet JavaScript library to render the output maps, which is user-friendly and has a lot of features. However, some alternative rendering libraries could be more performant (work more smoothly on larger datasets). mapview allows to set alternative rendering libraries ("leafgl" and "mapdeck") in the mapviewOptions()
  
```{r}
library(mapview)

oberfranken = subset(franconia, district == "Oberfranken")

trails |>
  st_transform(st_crs(oberfranken)) |>
  st_intersection(oberfranken) |>
  st_collection_extract("LINESTRING") |>
  mapview(color = "red", lwd = 3, layer.name = "trails") +
  mapview(franconia, zcol = "district") +
  breweries
```
 
 Last but not least is leaflet which is the most mature and widely used interactive mapping package in R. leaflet provides a relatively low-level interface to the Leaflet JavaScript library 
 
 Leaflet maps are created with leaflet(), the result of which is a leaflet map object which can be piped to other leaflet functions. This allows multiple map layers and control settings to be added 
 
```{r}
pal = colorNumeric("RdYlBu", domain = cycle_hire$nbikes)

leaflet(data = cycle_hire) |> 
  addProviderTiles(providers$CartoDB.Positron) |>
  addCircles(col = ~pal(nbikes), opacity = 0.9) |> 
  addPolygons(data = lnd, fill = FALSE) |> 
  addLegend(pal = pal, values = ~nbikes) |> 
  setView(lng = -0.1, 51.5, zoom = 12) |> 
  addMiniMap()
```
 
 
# ========================================
# ========================================

# how can I add point from a database to a tmap?


https://stackoverflow.com/questions/60551639/how-can-i-add-point-from-a-database-to-a-tmap 

```{r}
library(rnaturalearth)
library(sf)
library(tmap)

```

```{r}
lat <- c(41.88333,41.88333,44.95971,45.16110,45.16110,45.16110,45.16110,
45.16110,45.16110,45.16110,45.16110,45.16110,45.16110,45.16110,
45.16110,45.16110,45.16110,45.29775,45.29775,45.13333,45.16110,
45.29775,45.29775,45.29775,45.29775,45.29775,45.18885,45.19092)


long <- c(12.500000,12.500000,10.689220,9.701432,9.701432,9.701432,
9.701432,9.701432,9.701432,9.701432,9.701432,9.701432,
9.701432,9.701432,9.701432,9.701432,9.701432,11.658382,
11.658382,10.033333,9.701432,11.658382,11.658382,11.658382,
11.658382,11.658382,9.690454,9.726434)

cita <- data.frame(lat, long)
cita
```
```{r}
ita = ne_countries(country = "Italy") 
ita_sf = st_as_sf(ita)

cita_sf = st_as_sf(cita, coords = c('long', 'lat'), crs = st_crs(ita_sf)$proj4string)

```





```{r}
tm_shape(ita_sf) +
  tm_fill() +
  tm_borders() 
```

```{r}
tm_shape(cita_sf) +
  tm_dots( size=.5,fill="blue")  
```
```{r}
tm_shape(ita_sf) +
  tm_fill() +
  tm_borders() +
  tm_shape(cita_sf) +
  tm_dots( size=.5,fill="blue")  
```

